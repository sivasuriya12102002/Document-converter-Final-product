pipeline {
    agent any
    
    environment {
        // AWS Configuration
        AWS_REGION = 'us-west-2'
        AWS_ACCOUNT_ID = credentials('aws-account-id')
        EKS_CLUSTER_NAME = 'get-converted-exams-cluster'
        ECR_REPOSITORY = 'get-converted-exams'
        
        // Application Configuration
        APP_NAME = 'get-converted-exams'
        NAMESPACE = 'get-converted-exams'
        
        // Docker Configuration
        DOCKER_IMAGE = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}"
        IMAGE_TAG = "${BUILD_NUMBER}-${GIT_COMMIT.take(7)}"
        
        // Credentials
        AWS_CREDENTIALS = credentials('aws-credentials')
        GITHUB_CREDENTIALS = credentials('github-token')
        KUBECONFIG_CREDENTIAL = credentials('kubeconfig-file')
        SLACK_WEBHOOK = credentials('slack-webhook-url')
        SONARQUBE_TOKEN = credentials('sonarqube-token')
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
        skipStagesAfterUnstable()
        retry(3)
        parallelsAlwaysFailFast()
    }
    
    triggers {
        githubPush()
        pollSCM('H/5 * * * *') // Poll every 5 minutes as backup
        cron('H 2 * * 0') // Weekly build on Sunday at 2 AM
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "üîÑ Checking out code from GitHub..."
                    checkout scm
                    
                    // Get commit information
                    env.GIT_COMMIT_MSG = sh(
                        script: 'git log -1 --pretty=%B',
                        returnStdout: true
                    ).trim()
                    
                    env.GIT_AUTHOR = sh(
                        script: 'git log -1 --pretty=%an',
                        returnStdout: true
                    ).trim()
                    
                    env.GIT_BRANCH = sh(
                        script: 'git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()
                    
                    echo "üìù Commit: ${env.GIT_COMMIT}"
                    echo "üí¨ Message: ${env.GIT_COMMIT_MSG}"
                    echo "üë§ Author: ${env.GIT_AUTHOR}"
                    echo "üåø Branch: ${env.GIT_BRANCH}"
                }
            }
        }
        
        stage('Code Quality & Security') {
            parallel {
                stage('SonarQube Analysis') {
                    steps {
                        script {
                            echo "üîç Running SonarQube code analysis..."
                            withSonarQubeEnv('SonarQube') {
                                sh '''
                                    sonar-scanner \
                                        -Dsonar.projectKey=get-converted-exams \
                                        -Dsonar.sources=src \
                                        -Dsonar.host.url=$SONAR_HOST_URL \
                                        -Dsonar.login=$SONARQUBE_TOKEN
                                '''
                            }
                        }
                    }
                }
                
                stage('Dependency Check') {
                    steps {
                        script {
                            echo "üîí Running dependency vulnerability scan..."
                            sh '''
                                npm audit --audit-level moderate
                                npm audit fix --force || true
                            '''
                        }
                    }
                }
                
                stage('License Check') {
                    steps {
                        script {
                            echo "üìÑ Checking license compliance..."
                            sh '''
                                npx license-checker --summary
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Build Dependencies') {
            parallel {
                stage('Build Rust WASM') {
                    steps {
                        script {
                            echo "ü¶Ä Building Rust WASM module..."
                            sh '''
                                cd rust-formatter
                                # Remove existing Cargo.lock to avoid version conflicts
                                rm -f Cargo.lock
                                # Update Rust toolchain
                                rustup update stable
                                rustup target add wasm32-unknown-unknown
                                # Build WASM module
                                wasm-pack build --target web --out-dir pkg
                                # Verify WASM build
                                ls -la pkg/
                            '''
                        }
                    }
                }
                
                stage('Build Python WASM') {
                    steps {
                        script {
                            echo "üêç Building Python WASM components..."
                            sh '''
                                python3 scripts/build_python_wasm.py
                                # Verify Python modules
                                ls -la src/python_modules/
                            '''
                        }
                    }
                }
                
                stage('Install Node Dependencies') {
                    steps {
                        script {
                            echo "üì¶ Installing Node.js dependencies..."
                            sh '''
                                npm ci --production=false
                                # Cache node_modules for faster builds
                                tar -czf node_modules.tar.gz node_modules/
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Test & Quality Checks') {
            parallel {
                stage('Lint Code') {
                    steps {
                        script {
                            echo "üîç Running code linting..."
                            sh '''
                                npm run lint
                                # Generate lint report
                                npm run lint -- --format json > lint-report.json || true
                            '''
                        }
                    }
                    post {
                        always {
                            publishHTML([
                                allowMissing: false,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: '.',
                                reportFiles: 'lint-report.json',
                                reportName: 'ESLint Report'
                            ])
                        }
                    }
                }
                
                stage('Unit Tests') {
                    steps {
                        script {
                            echo "üß™ Running unit tests..."
                            sh '''
                                npm test -- --coverage --watchAll=false
                            '''
                        }
                    }
                    post {
                        always {
                            publishTestResults testResultsPattern: 'coverage/lcov.info'
                            publishHTML([
                                allowMissing: false,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'coverage/lcov-report',
                                reportFiles: 'index.html',
                                reportName: 'Coverage Report'
                            ])
                        }
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        script {
                            echo "üîí Running security scan..."
                            sh '''
                                # Scan for vulnerabilities
                                npm audit --audit-level moderate
                                
                                # Install and run Trivy for filesystem scan
                                curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
                                trivy fs . --format json --output trivy-report.json
                            '''
                        }
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'trivy-report.json', fingerprint: true
                        }
                    }
                }
            }
        }
        
        stage('Build Application') {
            steps {
                script {
                    echo "üèóÔ∏è Building React application..."
                    sh '''
                        # Build all components
                        npm run build:all
                        
                        # Verify build output
                        ls -la dist/
                        
                        # Generate build report
                        du -sh dist/* > build-report.txt
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'dist/**/*', fingerprint: true
                    archiveArtifacts artifacts: 'build-report.txt', fingerprint: true
                }
            }
        }
        
        stage('Build & Push Docker Image') {
            steps {
                script {
                    echo "üê≥ Building and pushing Docker image..."
                    
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', 
                                    credentialsId: 'aws-credentials']]) {
                        sh '''
                            # Login to ECR
                            aws ecr get-login-password --region ${AWS_REGION} | \
                                docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
                            
                            # Build Docker image
                            docker build -t ${ECR_REPOSITORY}:${IMAGE_TAG} .
                            docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${DOCKER_IMAGE}:${IMAGE_TAG}
                            docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${DOCKER_IMAGE}:latest
                            
                            # Scan Docker image for vulnerabilities
                            trivy image ${ECR_REPOSITORY}:${IMAGE_TAG} --format json --output docker-scan.json
                            
                            # Push to ECR
                            docker push ${DOCKER_IMAGE}:${IMAGE_TAG}
                            docker push ${DOCKER_IMAGE}:latest
                            
                            echo "‚úÖ Image pushed: ${DOCKER_IMAGE}:${IMAGE_TAG}"
                        '''
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'docker-scan.json', fingerprint: true
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'staging'
                }
            }
            steps {
                script {
                    echo "üöÄ Deploying to Staging Environment..."
                    deployToEnvironment('staging', 'get-converted-exams-staging')
                }
            }
        }
        
        stage('Deploy to EKS') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "üöÄ Deploying to AWS EKS..."
                    deployToEnvironment('production', NAMESPACE)
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    echo "üè• Performing health checks..."
                    
                    withCredentials([file(credentialsId: 'kubeconfig-file', variable: 'KUBECONFIG_FILE')]) {
                        sh '''
                            export KUBECONFIG=${KUBECONFIG_FILE}
                            
                            # Check pod health
                            kubectl get pods -n ${NAMESPACE} -l app=${APP_NAME}
                            
                            # Check if all pods are ready
                            kubectl wait --for=condition=ready pod -l app=${APP_NAME} -n ${NAMESPACE} --timeout=300s
                            
                            # Run smoke tests
                            kubectl run smoke-test --image=curlimages/curl:latest --rm -i --restart=Never -- \
                                curl -f http://${APP_NAME}-service.${NAMESPACE}.svc.cluster.local/health
                            
                            # Get service endpoint
                            EXTERNAL_IP=$(kubectl get ingress ${APP_NAME}-ingress -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "Not configured")
                            echo "üåê Application endpoint: ${EXTERNAL_IP}"
                            
                            # External health check
                            if [ "$EXTERNAL_IP" != "Not configured" ]; then
                                echo "‚è≥ Waiting for application to be ready..."
                                sleep 30
                                for i in {1..5}; do
                                    if curl -f http://${EXTERNAL_IP}/health; then
                                        echo "‚úÖ Health check passed"
                                        break
                                    else
                                        echo "‚ö†Ô∏è Health check failed, attempt $i/5"
                                        sleep 10
                                    fi
                                done
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Performance Tests') {
            steps {
                script {
                    echo "‚ö° Running performance tests..."
                    sh '''
                        # Install k6 for load testing
                        curl -s https://github.com/grafana/k6/releases/download/v0.47.0/k6-v0.47.0-linux-amd64.tar.gz | tar xvz --strip-components 1
                        
                        # Run basic load test
                        ./k6 run --vus 10 --duration 30s - <<EOF
import http from 'k6/http';
import { check } from 'k6';

export default function() {
  let response = http.get('http://${APP_NAME}-service.${NAMESPACE}.svc.cluster.local');
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
}
EOF
                    '''
                }
            }
        }
        
        stage('Cleanup') {
            steps {
                script {
                    echo "üßπ Cleaning up old resources..."
                    sh '''
                        # Clean up old Docker images
                        docker image prune -f
                        
                        # Clean up old ECR images (keep last 10)
                        aws ecr describe-images --repository-name ${ECR_REPOSITORY} \
                            --query 'sort_by(imageDetails,&imagePushedAt)[:-10].[imageDigest]' \
                            --output text | while read digest; do
                            if [ ! -z "$digest" ]; then
                                aws ecr batch-delete-image --repository-name ${ECR_REPOSITORY} \
                                    --image-ids imageDigest=$digest
                            fi
                        done
                        
                        # Clean up build artifacts
                        rm -rf node_modules/.cache
                        rm -f node_modules.tar.gz
                    '''
                }
            }
        }
    }
    
    post {
        always {
            script {
                echo "üßπ Cleaning up..."
                
                // Archive important artifacts
                archiveArtifacts artifacts: '**/*.log', allowEmptyArchive: true
                
                // Publish test results
                publishTestResults testResultsPattern: 'test-results.xml'
                
                // Clean workspace
                cleanWs()
            }
        }
        
        success {
            script {
                echo "‚úÖ Pipeline completed successfully!"
                
                // Send success notification to Slack
                sendSlackNotification('good', """
                    ‚úÖ *Deployment Successful*
                    
                    *Application:* ${APP_NAME}
                    *Environment:* ${env.GIT_BRANCH == 'main' ? 'Production' : 'Staging'}
                    *Image:* ${DOCKER_IMAGE}:${IMAGE_TAG}
                    *Commit:* ${env.GIT_COMMIT.take(7)} by ${env.GIT_AUTHOR}
                    *Message:* ${env.GIT_COMMIT_MSG}
                    *Build:* #${BUILD_NUMBER}
                    *Duration:* ${currentBuild.durationString}
                    *Branch:* ${env.GIT_BRANCH}
                """)
                
                // Send email notification
                emailext (
                    subject: "‚úÖ Deployment Successful - ${APP_NAME} #${BUILD_NUMBER}",
                    body: """
                        <h2>Deployment Successful</h2>
                        <p><strong>Application:</strong> ${APP_NAME}</p>
                        <p><strong>Environment:</strong> ${env.GIT_BRANCH == 'main' ? 'Production' : 'Staging'}</p>
                        <p><strong>Build:</strong> #${BUILD_NUMBER}</p>
                        <p><strong>Commit:</strong> ${env.GIT_COMMIT.take(7)} by ${env.GIT_AUTHOR}</p>
                        <p><strong>Duration:</strong> ${currentBuild.durationString}</p>
                        <p><strong>Branch:</strong> ${env.GIT_BRANCH}</p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL ?: 'team@company.com'}",
                    mimeType: 'text/html'
                )
            }
        }
        
        failure {
            script {
                echo "‚ùå Pipeline failed!"
                
                // Rollback on production failure
                if (env.GIT_BRANCH == 'main') {
                    script {
                        try {
                            echo "üîÑ Rolling back deployment..."
                            withCredentials([file(credentialsId: 'kubeconfig-file', variable: 'KUBECONFIG_FILE')]) {
                                sh '''
                                    export KUBECONFIG=${KUBECONFIG_FILE}
                                    kubectl rollout undo deployment/${APP_NAME} -n ${NAMESPACE}
                                    kubectl rollout status deployment/${APP_NAME} -n ${NAMESPACE}
                                '''
                            }
                        } catch (Exception e) {
                            echo "‚ùå Rollback failed: ${e.message}"
                        }
                    }
                }
                
                // Send failure notification
                sendSlackNotification('danger', """
                    ‚ùå *Deployment Failed*
                    
                    *Application:* ${APP_NAME}
                    *Environment:* ${env.GIT_BRANCH == 'main' ? 'Production' : 'Staging'}
                    *Commit:* ${env.GIT_COMMIT.take(7)} by ${env.GIT_AUTHOR}
                    *Build:* #${BUILD_NUMBER}
                    *Failed Stage:* ${env.STAGE_NAME}
                    *Duration:* ${currentBuild.durationString}
                    *Branch:* ${env.GIT_BRANCH}
                    
                    Please check the build logs for details.
                    ${env.GIT_BRANCH == 'main' ? 'üîÑ Automatic rollback initiated.' : ''}
                """)
            }
        }
        
        unstable {
            script {
                echo "‚ö†Ô∏è Pipeline completed with warnings!"
                
                sendSlackNotification('warning', """
                    ‚ö†Ô∏è *Deployment Completed with Warnings*
                    
                    *Application:* ${APP_NAME}
                    *Build:* #${BUILD_NUMBER}
                    *Branch:* ${env.GIT_BRANCH}
                    
                    Please review the build logs for warnings.
                """)
            }
        }
    }
}

// Helper function for deployment
def deployToEnvironment(String environment, String namespace) {
    withCredentials([
        [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials'],
        file(credentialsId: 'kubeconfig-file', variable: 'KUBECONFIG_FILE')
    ]) {
        sh """
            # Setup kubectl
            export KUBECONFIG=\${KUBECONFIG_FILE}
            
            # Update kubeconfig for EKS
            aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
            
            # Verify cluster connection
            kubectl cluster-info
            
            # Create namespace if it doesn't exist
            kubectl create namespace ${namespace} --dry-run=client -o yaml | kubectl apply -f -
            
            # Update deployment with new image
            kubectl set image deployment/${APP_NAME} \
                ${APP_NAME}=${DOCKER_IMAGE}:${IMAGE_TAG} \
                -n ${namespace}
            
            # Wait for rollout to complete
            kubectl rollout status deployment/${APP_NAME} -n ${namespace} --timeout=600s
            
            # Verify deployment
            kubectl get pods -n ${namespace}
            kubectl get services -n ${namespace}
            
            echo "‚úÖ Deployed to ${environment} environment"
        """
    }
}

// Helper function for Slack notifications
def sendSlackNotification(String color, String message) {
    try {
        slackSend(
            channel: '#deployments',
            color: color,
            message: message
        )
    } catch (Exception e) {
        echo "Failed to send Slack notification: ${e.message}"
    }
}